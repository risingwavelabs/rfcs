---
feature: Stream Executor with Emit on Close Semantics
authors:
  - "st1page"
start_date: "2023/02/14"
---

# Stream Executor with Emit on Close Semantics 

## Summary

Introduce a new component Sort Buffer used in the streaming executor and give a general method to implement EMIT ON CLOSE stream executor. Sort Buffer can support materialize and persistent the changes stream and drain the "stable" records with the input watermark. Because the input watermarks are always monotonically increasing, the output records are ordered by the watermark column and append-only.

***Note: In this RFC, we will focus on the EMIT ON CLOSE query***

## Background and Definitions 
Let's look back on the current designs and RFCs. 

The [RFC: The Semantics of EMIT ON WINDOW CLOSE](https://github.com/risingwavelabs/rfcs/pull/30) has given a strict definition of the semantics of **EMIT ON WINDOW CLOSE**. In short, the streaming job with the "EMIT ON CLOSE" modifier emits the result when the result is complete, and no sooner, no later. In other words, the "EMIT ON CLOSE" streaming query gives an append-only result as soon as possible.

According to the same RFC(EMIT ON CLOSE), The **User-defined Watermark** on the source make the user a way to declare which records from the source are outdated and can be discarded. Watermark gives a bound of the data as the data inputs, which provides the guarantee that some results are complete and triggers the emitting of the EMIT ON CLOSE query.

And [RFC: The WatermarkFilter and StreamSort operator](https://github.com/risingwavelabs/rfcs/pull/2) introduces the WatermarkFilter stream operator. With the "user-defined watermark" and continuous ingested data, WatermarkFilter can generate consistent **Internal Watermark Stream Message** (hereinafter referred to as **"Watermark"** or **"Watermark message"**). A Watermark message with column index and value means there will be no data that have a larger watermark column value than the value in the watermark.

Also, the RFC proposes the **Watermark Derivation** of the stream operator. This design makes sure that all possible trigger messages generated by **User-defined Watermark** can be expressed as the **Watermark message**. The only thing that can transfer between
the stream operator is the Watermark message so the stream operator does not need to be aware of the "time window" or other concepts. The executor just needs to handle the input watermark no matter whether the watermark column is a "window_close" or a temporal filter's output column.

And then we can introduce **EMIT ON CLOSE Flag** on any stream operator now. The stream operator with the flag works can make sure some result is complete with the input watermark and then emit them. If most downstream stream operator has EMIT ON CLOSE Flag, the streaming query can satisfy the EMIT ON WINDOW CLOSE semantics. 

In this RFC, we will focus on how to implement a stream executor with EMIT ON WINDOW CLOSE flag and reuse the logic of the normal stream executor.

## Sort Buffer Design

Compared with the normal stream executor, the EMIT ON CLOSE executor needs to buffer the data until the result is complete. A general component `SortBuffer` is introduced here for executors. 
SortBuffer consists of two parts, SortBufferCache and SortBufferTable. 
- SortBufferTable
  - A state table to persist the buffered data. 
  - The primary key's first column is a watermark column. We call it as **sort key**
- SortBufferCache
  - A row cache on the SortBufferTable
  - can accept watermark to know some rows have been complete
  - can drain the complete row in the memory ordered by the sort key.

And the SortBufferTable is just a normal StateTable, we will only need to implement the SortBufferCache.
```rust 
impl SortBufferCache{
  /// consume the next row ordered by the first column which is complete.
  /// return None if there is no remaining complete row.
  /// fill cache from the state table when cache miss.
  /// will consume the row in memory.
  fn next(&mut self, table: &StateTable) -> Option<Row>;

  /// use the first column's watermark to refresh the SortBuffer
  /// can trigger more rows complete which can be returned by `self.next`
  fn accept_watermark(&mut self, watermark: Watermark);
  
  /// apply changes operations
  fn insert(&mut self, row: Row);
  fn delete(&mut self, row: Row);
  fn apply_chunk(&mut self, c: Chunk);

  /// recovery from the stateTable, just gets the row belonging to stateTable's vnode.
  fn recovery(&mut self, table: &StateTable);
}

```
The component does not take over so many things. There are still lots of things that should be done by the executor, such as
- all the operations should be applied on the table and cache, and the executor should write in duplicate. 
- after getting the complete data, the executor must delete the useless data by itself (delete one by one/range delete with the last key). Notice that it is different with state clean and the data must be deleted consistently.

And then we will see why and how it works in different situations.
## Executors
### Sort
### GroupAgg
### OverAggExec
### DynFilter
### EqJoin
### IntervalJoin
